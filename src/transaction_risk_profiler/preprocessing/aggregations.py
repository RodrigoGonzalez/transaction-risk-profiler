from collections import defaultdict
from collections.abc import Callable
from collections.abc import Iterable
from typing import Any
from typing import TypeVar

T = TypeVar("T")
V = TypeVar("V")


def group_by_elements(key_selector: Callable[[T], V], sequence: Iterable[T]) -> dict[V, list[T]]:
    """
    Groups elements in an iterable by a given key selector function.

    The function takes an iterable and a key selector function. It iterates
    through the iterable, applying the key selector function to each element.
    The function then groups elements by the unique keys generated by the key
    selector.

    Parameters
    ----------
    key_selector : Callable[[T], V]
        A function that takes an element of type `T` and returns a key of type
        `V`.

    sequence : Iterable[T]
        An iterable of elements of a type `T`.

    Returns
    -------
    dict[V, list[T]]
        A dictionary where each key is of type `V` and maps to a list of
        elements of a type `T`.

    Examples
    --------
    >>> group_by_elements(lambda x: x % 2, [1, 2, 3, 4, 5])
    {1: [1, 3, 5], 0: [2, 4]}
    """
    grouped_elements = defaultdict(list)

    for element in sequence:
        key = key_selector(element)
        grouped_elements[key].append(element)

    return grouped_elements


def generate_aggregation_schema(item: str) -> dict[str, dict[str, Any]]:
    """
    Generates an aggregation schema dictionary for a given item.

    The function creates a dictionary that maps the type of the field (e.g.,
    'amount', 'country', 'state') to a dictionary of aggregation functions
    (e.g., sum, min, max, mean, etc.). The function also appends the item's
    name to the aggregation keys.

    Parameters
    ----------
    item : str
        The name of the item for which the aggregation schema is generated.

    Returns
    -------
    dict[str, dict[str, Any]]
        A nested dictionary containing the aggregation schema.

    Examples
    --------
    >>> generate_aggregation_schema('product')
    {
        'amount': {
            'product_amt_sum': 'sum',
            'product_amt_min': 'min',
            'product_amt_max': 'max',
            'product_amt_mean': 'mean',
            'product_amt_count': 'count',
            'product_amt_std': 'std'
        },
        'country': {
            'product_country_count': <function>
        },
        'state': {
            'product_state_count': <function>
        }
    }
    """

    unique_count: Callable = lambda x: x.nunique()

    return {
        "amount": {
            f"{item}_amt_sum": "sum",
            f"{item}_amt_min": "min",
            f"{item}_amt_max": "max",
            f"{item}_amt_mean": "mean",
            f"{item}_amt_count": "count",
            f"{item}_amt_std": "std",
        },
        "country": {f"{item}_country_count": unique_count},
        "state": {f"{item}_state_count": unique_count},
    }
